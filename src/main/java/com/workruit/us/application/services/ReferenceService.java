package com.workruit.us.application.services;

import java.util.*;
import java.util.stream.Collectors;

import com.workruit.us.application.configuration.WorkruitException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.workruit.us.application.dto.ReferenceDTO;
import com.workruit.us.application.models.Applicant;
import com.workruit.us.application.models.Reference;
import com.workruit.us.application.repositories.ApplicantRepository;
import com.workruit.us.application.repositories.ReferenceRepository;

/**
 * Generated by Spring Data Generator on 25/11/2022
 */
@Component
public class ReferenceService {

    private @Autowired ReferenceRepository referenceRepository;
    private @Autowired ApplicantRepository applicantRepository;
    private @Autowired ApplicantService applicantService;

    public void updateReference(List<ReferenceDTO> referenceDTOs, Long applicantId, Long consultancyId) throws WorkruitException {
        Applicant applicant = applicantRepository.findByApplicantIdAndConsultancyId(applicantId, consultancyId)
                .orElseThrow(() -> new WorkruitException(String.format("Applicant is not found with id: %s", applicantId)));
        List<Reference> oldReferences = referenceRepository.findByApplicantId(applicantId);
        List<Reference> currentReferences = new ArrayList<Reference>();
        for (ReferenceDTO referenceDTO : referenceDTOs) {
            Reference reference = new Reference();
            if (referenceDTO.getReferenceId() == null || referenceDTO.getReferenceId() == 0) {
                reference.setCreatedDate(new Date());
            }
            reference.setApplicantId(applicantId);
            reference.setReferenceId(referenceDTO.getReferenceId());
            reference.setEmail(referenceDTO.getEmail());
            reference.setEmployer(referenceDTO.getEmployer());
            reference.setName(referenceDTO.getName());
            reference.setPhoneNumber(referenceDTO.getPhoneNumber());
            reference.setReferenceType(referenceDTO.getReferenceType());
            reference.setTitle(referenceDTO.getTitle());
            reference.setUpdatedDate(new Date());
            referenceRepository.save(reference);
            currentReferences.add(reference);
        }
        Set<Long> referenceIds = currentReferences.stream().map(e -> e.getReferenceId()).collect(Collectors.toSet());
        oldReferences.removeIf(e -> referenceIds.contains(e.getReferenceId()));
        for (Reference reference : oldReferences) {
            referenceRepository.deleteById(reference.getReferenceId());
        }
        applicant.setCorrectionRequired(!applicantService.isCorrectionSolved(applicantId));
        applicantRepository.save(applicant);
    }

    public List<ReferenceDTO> getReferences(Long applicantId, Long consultancyId) throws WorkruitException {
        Applicant applicant = applicantRepository.findByApplicantIdAndConsultancyId(applicantId, consultancyId)
                .orElseThrow(() -> new WorkruitException(String.format("Applicant is not found with id: %s", applicantId)));
        List<Reference> references = referenceRepository.findByApplicantId(applicantId);
        return references.stream().map(referenceDTO -> {
            ReferenceDTO reference = new ReferenceDTO();
            reference.setReferenceId(referenceDTO.getReferenceId());
            reference.setEmail(referenceDTO.getEmail());
            reference.setEmployer(referenceDTO.getEmployer());
            reference.setName(referenceDTO.getName());
            reference.setPhoneNumber(referenceDTO.getPhoneNumber());
            reference.setReferenceType(referenceDTO.getReferenceType());
            reference.setTitle(referenceDTO.getTitle());
            return reference;
        }).collect(Collectors.toList());
    }
}
